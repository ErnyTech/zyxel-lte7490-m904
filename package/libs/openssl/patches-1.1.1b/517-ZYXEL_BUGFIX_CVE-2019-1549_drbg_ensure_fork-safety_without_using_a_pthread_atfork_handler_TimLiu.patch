From 1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be Mon Sep 17 00:00:00 2001
From: "Dr. Matthias St. Pierre" <Matthias.St.Pierre@ncp-e.com>
Date: Mon, 27 May 2019 21:03:09 +0200
Subject: [PATCH] drbg: ensure fork-safety without using a pthread_atfork
 handler

When the new OpenSSL CSPRNG was introduced in version 1.1.1,
it was announced in the release notes that it would be fork-safe,
which the old CSPRNG hadn't been.

The fork-safety was implemented using a fork count, which was
incremented by a pthread_atfork handler. Initially, this handler
was enabled by default. Unfortunately, the default behaviour
had to be changed for other reasons in commit b5319bdbd095, so
the new OpenSSL CSPRNG failed to keep its promise.

This commit restores the fork-safety using a different approach.
It replaces the fork count by a fork id, which coincides with
the process id on UNIX-like operating systems and is zero on other
operating systems. It is used to detect when an automatic reseed
after a fork is necessary.

To prevent a future regression, it also adds a test to verify that
the child reseeds after fork.

CVE-2019-1549

Reviewed-by: Paul Dale <paul.dale@oracle.com>
Reviewed-by: Matt Caswell <matt@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/9802)
---
 crypto/include/internal/rand_int.h |  1 -
 crypto/init.c                      |  1 -
 crypto/rand/drbg_lib.c             |  9 ++++--
 crypto/rand/rand_lcl.h             | 23 ++++-----------
 crypto/rand/rand_lib.c             |  7 -----
 crypto/threads_none.c              | 13 +++++++++
 crypto/threads_pthread.c           | 10 +++++++
 crypto/threads_win.c               |  4 +++
 include/internal/cryptlib.h        |  1 +
 test/drbgtest.c                    | 45 ++++++++++++++++++++++++++++++
 10 files changed, 84 insertions(+), 30 deletions(-)

Index: openssl-1.1.1b/crypto/include/internal/rand_int.h
===================================================================
--- openssl-1.1.1b.orig/crypto/include/internal/rand_int.h	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/include/internal/rand_int.h	2021-01-06 18:41:18.068309617 +0800
@@ -26,7 +26,6 @@
 void rand_cleanup_int(void);
 void rand_drbg_cleanup_int(void);
 void drbg_delete_thread_state(void);
-void rand_fork(void);
 
 /* Hardware-based seeding functions. */
 size_t rand_acquire_entropy_from_tsc(RAND_POOL *pool);
Index: openssl-1.1.1b/crypto/init.c
===================================================================
--- openssl-1.1.1b.orig/crypto/init.c	2021-01-06 18:33:17.918150785 +0800
+++ openssl-1.1.1b/crypto/init.c	2021-01-06 18:41:18.068309617 +0800
@@ -849,6 +849,5 @@
 
 void OPENSSL_fork_child(void)
 {
-    rand_fork();
 }
 #endif
Index: openssl-1.1.1b/crypto/rand/drbg_lib.c
===================================================================
--- openssl-1.1.1b.orig/crypto/rand/drbg_lib.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/rand/drbg_lib.c	2021-01-06 18:41:18.068309617 +0800
@@ -197,7 +197,7 @@
     }
 
     drbg->secure = secure && CRYPTO_secure_allocated(drbg);
-    drbg->fork_count = rand_fork_count;
+    drbg->fork_id = openssl_get_fork_id();
     drbg->parent = parent;
 
     if (parent == NULL) {
@@ -578,6 +578,7 @@
                        int prediction_resistance,
                        const unsigned char *adin, size_t adinlen)
 {
+    int fork_id;
     int reseed_required = 0;
 
     if (drbg->state != DRBG_READY) {
@@ -603,8 +604,10 @@
         return 0;
     }
 
-    if (drbg->fork_count != rand_fork_count) {
-        drbg->fork_count = rand_fork_count;
+    fork_id = openssl_get_fork_id();
+
+    if (drbg->fork_id != fork_id) {
+        drbg->fork_id = fork_id;
         reseed_required = 1;
     }
 
Index: openssl-1.1.1b/crypto/rand/rand_lcl.h
===================================================================
--- openssl-1.1.1b.orig/crypto/rand/rand_lcl.h	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/rand/rand_lcl.h	2021-01-06 18:41:18.068309617 +0800
@@ -167,12 +167,12 @@
     int secure; /* 1: allocated on the secure heap, 0: otherwise */
     int type; /* the nid of the underlying algorithm */
     /*
-     * Stores the value of the rand_fork_count global as of when we last
-     * reseeded.  The DRBG reseeds automatically whenever drbg->fork_count !=
-     * rand_fork_count.  Used to provide fork-safety and reseed this DRBG in
-     * the child process.
+     * Stores the return value of openssl_get_fork_id() as of when we last
+     * reseeded.  The DRBG reseeds automatically whenever drbg->fork_id !=
+     * openssl_get_fork_id().  Used to provide fork-safety and reseed this
+     * DRBG in the child process.
      */
-    int fork_count;
+    int fork_id;
     unsigned short flags; /* various external flags */
 
     /*
@@ -264,19 +264,6 @@
 /* The global RAND method, and the global buffer and DRBG instance. */
 extern RAND_METHOD rand_meth;
 
-/*
- * A "generation count" of forks.  Incremented in the child process after a
- * fork.  Since rand_fork_count is increment-only, and only ever written to in
- * the child process of the fork, which is guaranteed to be single-threaded, no
- * locking is needed for normal (read) accesses; the rest of pthread fork
- * processing is assumed to introduce the necessary memory barriers.  Sibling
- * children of a given parent will produce duplicate values, but this is not
- * problematic because the reseeding process pulls input from the system CSPRNG
- * and/or other global sources, so the siblings will end up generating
- * different output streams.
- */
-extern int rand_fork_count;
-
 /* DRBG helpers */
 int rand_drbg_restart(RAND_DRBG *drbg,
                       const unsigned char *buffer, size_t len, size_t entropy);
Index: openssl-1.1.1b/crypto/rand/rand_lib.c
===================================================================
--- openssl-1.1.1b.orig/crypto/rand/rand_lib.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/rand/rand_lib.c	2021-01-06 18:41:18.068309617 +0800
@@ -26,8 +26,6 @@
 static const RAND_METHOD *default_RAND_meth;
 static CRYPTO_ONCE rand_init = CRYPTO_ONCE_STATIC_INIT;
 
-int rand_fork_count;
-
 static CRYPTO_RWLOCK *rand_nonce_lock;
 static int rand_nonce_count;
 
@@ -298,11 +296,6 @@
     rand_pool_reattach(pool, out);
 }
 
-void rand_fork(void)
-{
-    rand_fork_count++;
-}
-
 DEFINE_RUN_ONCE_STATIC(do_rand_init)
 {
 #ifndef OPENSSL_NO_ENGINE
Index: openssl-1.1.1b/crypto/threads_none.c
===================================================================
--- openssl-1.1.1b.orig/crypto/threads_none.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/threads_none.c	2021-01-06 18:41:18.072309617 +0800
@@ -12,6 +12,11 @@
 
 #if !defined(OPENSSL_THREADS) || defined(CRYPTO_TDEBUG)
 
+# if defined(OPENSSL_SYS_UNIX)
+#  include <sys/types.h>
+#  include <unistd.h>
+# endif
+
 CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)
 {
     CRYPTO_RWLOCK *lock;
@@ -133,4 +138,12 @@
     return 0;
 }
 
+int openssl_get_fork_id(void)
+{
+# if defined(OPENSSL_SYS_UNIX)
+    return getpid();
+# else
+    return return 0;
+# endif
+}
 #endif
Index: openssl-1.1.1b/crypto/threads_pthread.c
===================================================================
--- openssl-1.1.1b.orig/crypto/threads_pthread.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/threads_pthread.c	2021-01-06 18:41:18.072309617 +0800
@@ -12,6 +12,11 @@
 
 #if defined(OPENSSL_THREADS) && !defined(CRYPTO_TDEBUG) && !defined(OPENSSL_SYS_WINDOWS)
 
+# if defined(OPENSSL_SYS_UNIX)
+#  include <sys/types.h>
+#  include <unistd.h>
+#endif
+
 # ifdef PTHREAD_RWLOCK_INITIALIZER
 #  define USE_RWLOCK
 # endif
@@ -193,4 +198,9 @@
 # endif
     return 0;
 }
+
+int openssl_get_fork_id(void)
+{
+    return getpid();
+}
 #endif
Index: openssl-1.1.1b/crypto/threads_win.c
===================================================================
--- openssl-1.1.1b.orig/crypto/threads_win.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/crypto/threads_win.c	2021-01-06 18:41:18.072309617 +0800
@@ -160,4 +160,8 @@
     return 0;
 }
 
+int openssl_get_fork_id(void)
+{
+    return 0;
+}
 #endif
Index: openssl-1.1.1b/include/internal/cryptlib.h
===================================================================
--- openssl-1.1.1b.orig/include/internal/cryptlib.h	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/include/internal/cryptlib.h	2021-01-06 18:41:18.072309617 +0800
@@ -80,6 +80,7 @@
 void OPENSSL_showfatal(const char *fmta, ...);
 void crypto_cleanup_all_ex_data_int(void);
 int openssl_init_fork_handlers(void);
+int openssl_get_fork_id(void);
 
 char *ossl_safe_getenv(const char *name);
 
Index: openssl-1.1.1b/test/drbgtest.c
===================================================================
--- openssl-1.1.1b.orig/test/drbgtest.c	2019-02-26 22:15:30.000000000 +0800
+++ openssl-1.1.1b/test/drbgtest.c	2021-01-06 18:41:18.072309617 +0800
@@ -22,6 +22,13 @@
 # include <windows.h>
 #endif
 
+
+#if defined(OPENSSL_SYS_UNIX)
+# include <sys/types.h>
+# include <sys/wait.h>
+# include <unistd.h>
+#endif
+
 #include "testutil.h"
 #include "drbgtest.h"
 
@@ -669,6 +676,40 @@
     return 1;
 }
 
+
+#if defined(OPENSSL_SYS_UNIX)
+/*
+ * Test whether master, public and private DRBG are reseeded after
+ * forking the process.
+ */
+static int test_drbg_reseed_after_fork(RAND_DRBG *master,
+                                       RAND_DRBG *public,
+                                       RAND_DRBG *private)
+{
+    pid_t pid;
+    int status=0;
+
+    pid = fork();
+    if (!TEST_int_ge(pid, 0))
+        return 0;
+
+    if (pid > 0) {
+        /* I'm the parent; wait for the child and check its exit code */
+        return TEST_int_eq(waitpid(pid, &status, 0), pid) && TEST_int_eq(status, 0);
+    }
+
+    /* I'm the child; check whether all three DRBGs reseed. */
+    if (!TEST_true(test_drbg_reseed(1, master, public, private, 1, 1, 1, 0)))
+        status = 1;
+
+    /* Remove hooks  */
+    unhook_drbg(master);
+    unhook_drbg(public);
+    unhook_drbg(private);
+    exit(status);
+}
+#endif
+
 /*
  * Test whether the default rand_method (RAND_OpenSSL()) is
  * setup correctly, in particular whether reseeding  works
@@ -755,6 +796,10 @@
         goto error;
     reset_drbg_hook_ctx();
 
+#if defined(OPENSSL_SYS_UNIX)
+    if (!TEST_true(test_drbg_reseed_after_fork(master, public, private)))
+        goto error;
+#endif
 
     /* fill 'randomness' buffer with some arbitrary data */
     memset(rand_add_buf, 'r', sizeof(rand_add_buf));
