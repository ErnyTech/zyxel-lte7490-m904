Index: linux-3.10.14/Documentation/networking/ip-sysctl.txt
===================================================================
--- linux-3.10.14.orig/Documentation/networking/ip-sysctl.txt	2016-01-08 14:04:19.000000000 +0800
+++ linux-3.10.14/Documentation/networking/ip-sysctl.txt	2019-06-28 16:24:28.751439583 +0800
@@ -166,6 +166,14 @@
 	Path MTU discovery (MTU probing).  If MTU probing is enabled,
 	this is the initial MSS used by the connection.
 
+tcp_min_snd_mss - INTEGER
+	TCP SYN and SYNACK messages usually advertise an ADVMSS option,
+	as described in RFC 1122 and RFC 6691.
+	If this ADVMSS option is smaller than tcp_min_snd_mss,
+	it is silently capped to tcp_min_snd_mss.
+
+	Default : 48 (at least 8 bytes of payload per segment)
+
 tcp_congestion_control - STRING
 	Set the congestion control algorithm to be used for new
 	connections. The algorithm "reno" is always available, but
Index: linux-3.10.14/include/net/netns/ipv4.h
===================================================================
--- linux-3.10.14.orig/include/net/netns/ipv4.h	2016-01-08 14:06:57.000000000 +0800
+++ linux-3.10.14/include/net/netns/ipv4.h	2019-06-28 16:29:45.783439583 +0800
@@ -63,7 +63,8 @@
 	int sysctl_icmp_errors_use_inbound_ifaddr;
 
 	int sysctl_tcp_ecn;
-
+	int sysctl_tcp_min_snd_mss;
+	
 	kgid_t sysctl_ping_group_range[2];
 	long sysctl_tcp_mem[3];
 
Index: linux-3.10.14/net/ipv4/sysctl_net_ipv4.c
===================================================================
--- linux-3.10.14.orig/net/ipv4/sysctl_net_ipv4.c	2016-01-08 14:07:06.000000000 +0800
+++ linux-3.10.14/net/ipv4/sysctl_net_ipv4.c	2019-06-28 16:32:48.499439583 +0800
@@ -34,6 +34,8 @@
 static int ip_local_port_range_max[] = { 65535, 65535 };
 static int tcp_adv_win_scale_min = -31;
 static int tcp_adv_win_scale_max = 31;
+static int tcp_min_snd_mss_min = TCP_MIN_SND_MSS;
+static int tcp_min_snd_mss_max = 65535;
 static int ip_ttl_min = 1;
 static int ip_ttl_max = 255;
 static int tcp_syn_retries_min = 1;
@@ -836,6 +838,15 @@
 		.proc_handler	= proc_dointvec
 	},
 	{
+		.procname	= "tcp_min_snd_mss",
+		.data		= &init_net.ipv4.sysctl_tcp_min_snd_mss,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &tcp_min_snd_mss_min,
+		.extra2		= &tcp_min_snd_mss_max,
+	},
+	{
 		.procname	= "tcp_mem",
 		.maxlen		= sizeof(init_net.ipv4.sysctl_tcp_mem),
 		.mode		= 0644,
Index: linux-3.10.14/net/ipv4/tcp_ipv4.c
===================================================================
--- linux-3.10.14.orig/net/ipv4/tcp_ipv4.c	2016-01-08 14:07:06.000000000 +0800
+++ linux-3.10.14/net/ipv4/tcp_ipv4.c	2019-06-28 16:36:41.919439583 +0800
@@ -2900,6 +2900,7 @@
 static int __net_init tcp_sk_init(struct net *net)
 {
 	net->ipv4.sysctl_tcp_ecn = 2;
+	net->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;
 	return 0;
 }
 
Index: linux-3.10.14/net/ipv4/tcp_output.c
===================================================================
--- linux-3.10.14.orig/net/ipv4/tcp_output.c	2019-06-28 15:42:36.999439583 +0800
+++ linux-3.10.14/net/ipv4/tcp_output.c	2019-06-28 16:37:50.583439583 +0800
@@ -1227,8 +1227,7 @@
 	mss_now -= icsk->icsk_ext_hdr_len;
 
 	/* Then reserve room for full set of TCP options and 8 bytes of data */
-	if (mss_now < TCP_MIN_SND_MSS)
-		mss_now = TCP_MIN_SND_MSS;
+	mss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);
 	return mss_now;
 }
 
Index: linux-3.10.14/net/ipv4/tcp_timer.c
===================================================================
--- linux-3.10.14.orig/net/ipv4/tcp_timer.c     2016-01-08 14:07:06.000000000 +0800
+++ linux-3.10.14/net/ipv4/tcp_timer.c  2019-06-28 18:09:44.323439583 +0800
@@ -108,11 +108,13 @@
 			tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
 		} else {
 			struct tcp_sock *tp = tcp_sk(sk);
+			struct net *net = sock_net(sk);
 			int mss;
 
 			mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
 			mss = min(sysctl_tcp_base_mss, mss);
 			mss = max(mss, 68 - tp->tcp_header_len);
+			mss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);
 			icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
 			tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
 		}
